<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess vs CPU</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;family=Inter:wght@400;500;600&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    .chess-piece {
      font-size: 2.5rem;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s ease;
    }
    .chess-piece:hover {
      transform: scale(1.1);
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .square.selected {
      box-shadow: inset 0 0 0 4px #fbbf24;
    }
    .square.valid-move {
      position: relative;
    }
    .square.valid-move::after {
      content: '';
      position: absolute;
      width: 30%;
      height: 30%;
      background: rgba(34, 197, 94, 0.6);
      border-radius: 50%;
    }
    .square.capture-move::after {
      width: 90%;
      height: 90%;
      background: transparent;
      border: 4px solid rgba(239, 68, 68, 0.6);
      border-radius: 50%;
    }
    @keyframes trophy-bounce {
      0%, 100% { transform: translateY(0) rotate(-5deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .trophy-animation {
      animation: trophy-bounce 1s ease-in-out infinite;
    }
    .confetti {
      position: fixed;
      animation: confetti-fall 3s ease-out forwards;
    }
    @keyframes fade-in-scale {
      0% { opacity: 0; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }
    .victory-modal {
      animation: fade-in-scale 0.5s ease-out forwards;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 overflow-auto">
  <div id="app" class="w-full min-h-full flex flex-col items-center justify-center p-4">
   <h1 id="game-title" class="text-3xl md:text-4xl font-bold text-amber-400 mb-2" style="font-family: 'Playfair Display', serif;">Chess vs CPU</h1>
   <p class="text-slate-400 mb-4 text-sm" style="font-family: 'Inter', sans-serif;">You play as White. Checkmate the CPU to win!</p>
   <div class="flex items-center gap-4 mb-4">
    <div id="turn-indicator" class="px-4 py-2 rounded-lg bg-slate-700 text-white font-medium" style="font-family: 'Inter', sans-serif;">
     Your Turn
    </div><button id="reset-btn" class="px-4 py-2 rounded-lg bg-amber-500 hover:bg-amber-600 text-slate-900 font-semibold transition-colors" style="font-family: 'Inter', sans-serif;"> New Game </button>
   </div>
   <div id="board" class="grid grid-cols-8 border-4 border-amber-600 rounded-lg overflow-hidden shadow-2xl" style="width: min(90vw, 480px); height: min(90vw, 480px);">
   </div>
   <div id="captured-pieces" class="mt-4 flex flex-wrap gap-2 justify-center max-w-md">
    <div id="white-captured" class="flex flex-wrap gap-1 p-2 bg-slate-700/50 rounded-lg min-w-[100px]"></div>
    <div id="black-captured" class="flex flex-wrap gap-1 p-2 bg-slate-700/50 rounded-lg min-w-[100px]"></div>
   </div>
  </div>
  <div id="victory-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
   <div class="victory-modal bg-gradient-to-br from-amber-500 to-yellow-600 p-8 rounded-2xl text-center shadow-2xl max-w-sm mx-4">
    <div class="trophy-animation text-8xl mb-4">
     üèÜ
    </div>
    <h2 class="text-3xl font-bold text-slate-900 mb-2" style="font-family: 'Playfair Display', serif;">Victory!</h2>
    <p id="victory-message" class="text-slate-800 mb-6" style="font-family: 'Inter', sans-serif;">You defeated the CPU!</p><button id="play-again-btn" class="px-6 py-3 bg-slate-900 text-amber-400 rounded-lg font-semibold hover:bg-slate-800 transition-colors" style="font-family: 'Inter', sans-serif;"> Play Again </button>
   </div>
  </div>
  <div id="game-over-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
   <div class="victory-modal bg-gradient-to-br from-slate-700 to-slate-800 p-8 rounded-2xl text-center shadow-2xl max-w-sm mx-4">
    <div class="text-8xl mb-4">
     üëë
    </div>
    <h2 id="game-over-title" class="text-3xl font-bold text-white mb-2" style="font-family: 'Playfair Display', serif;">Game Over</h2>
    <p id="game-over-message" class="text-slate-300 mb-6" style="font-family: 'Inter', sans-serif;">The CPU wins this time!</p><button id="retry-btn" class="px-6 py-3 bg-amber-500 text-slate-900 rounded-lg font-semibold hover:bg-amber-600 transition-colors" style="font-family: 'Inter', sans-serif;"> Try Again </button>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "Chess vs CPU"
    };

    const PIECES = {
      WHITE_KING: '‚ôî', WHITE_QUEEN: '‚ôï', WHITE_ROOK: '‚ôñ',
      WHITE_BISHOP: '‚ôó', WHITE_KNIGHT: '‚ôò', WHITE_PAWN: '‚ôô',
      BLACK_KING: '‚ôö', BLACK_QUEEN: '‚ôõ', BLACK_ROOK: '‚ôú',
      BLACK_BISHOP: '‚ôù', BLACK_KNIGHT: '‚ôû', BLACK_PAWN: '‚ôü'
    };

    const PIECE_VALUES = {
      '‚ôô': 10, '‚ôü': 10,
      '‚ôò': 30, '‚ôû': 30,
      '‚ôó': 30, '‚ôù': 30,
      '‚ôñ': 50, '‚ôú': 50,
      '‚ôï': 90, '‚ôõ': 90,
      '‚ôî': 900, '‚ôö': 900
    };

    let board = [];
    let selectedSquare = null;
    let validMoves = [];
    let isWhiteTurn = true;
    let gameOver = false;
    let whiteCaptured = [];
    let blackCaptured = [];

    function initBoard() {
      board = [
        ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
        ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
        ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
      ];
      selectedSquare = null;
      validMoves = [];
      isWhiteTurn = true;
      gameOver = false;
      whiteCaptured = [];
      blackCaptured = [];
      renderBoard();
      updateTurnIndicator();
      renderCapturedPieces();
    }

    function isWhitePiece(piece) {
      return '‚ôî‚ôï‚ôñ‚ôó‚ôò‚ôô'.includes(piece);
    }

    function isBlackPiece(piece) {
      return '‚ôö‚ôõ‚ôú‚ôù‚ôû‚ôü'.includes(piece);
    }

    function getValidMoves(row, col) {
      const piece = board[row][col];
      const moves = [];
      if (!piece) return moves;

      const isWhite = isWhitePiece(piece);

      switch (piece) {
        case '‚ôô':
          if (row > 0 && !board[row - 1][col]) {
            moves.push([row - 1, col]);
            if (row === 6 && !board[row - 2][col]) {
              moves.push([row - 2, col]);
            }
          }
          if (row > 0 && col > 0 && isBlackPiece(board[row - 1][col - 1])) {
            moves.push([row - 1, col - 1]);
          }
          if (row > 0 && col < 7 && isBlackPiece(board[row - 1][col + 1])) {
            moves.push([row - 1, col + 1]);
          }
          break;

        case '‚ôü':
          if (row < 7 && !board[row + 1][col]) {
            moves.push([row + 1, col]);
            if (row === 1 && !board[row + 2][col]) {
              moves.push([row + 2, col]);
            }
          }
          if (row < 7 && col > 0 && isWhitePiece(board[row + 1][col - 1])) {
            moves.push([row + 1, col - 1]);
          }
          if (row < 7 && col < 7 && isWhitePiece(board[row + 1][col + 1])) {
            moves.push([row + 1, col + 1]);
          }
          break;

        case '‚ôñ': case '‚ôú':
          addLineMoves(row, col, moves, isWhite, [[0, 1], [0, -1], [1, 0], [-1, 0]]);
          break;

        case '‚ôó': case '‚ôù':
          addLineMoves(row, col, moves, isWhite, [[1, 1], [1, -1], [-1, 1], [-1, -1]]);
          break;

        case '‚ôï': case '‚ôõ':
          addLineMoves(row, col, moves, isWhite, [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
          break;

        case '‚ôò': case '‚ôû':
          const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
          for (const [dr, dc] of knightMoves) {
            const nr = row + dr, nc = col + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
              const target = board[nr][nc];
              if (!target || (isWhite ? isBlackPiece(target) : isWhitePiece(target))) {
                moves.push([nr, nc]);
              }
            }
          }
          break;

        case '‚ôî': case '‚ôö':
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = row + dr, nc = col + dc;
              if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                const target = board[nr][nc];
                if (!target || (isWhite ? isBlackPiece(target) : isWhitePiece(target))) {
                  moves.push([nr, nc]);
                }
              }
            }
          }
          break;
      }

      return moves;
    }

    function addLineMoves(row, col, moves, isWhite, directions) {
      for (const [dr, dc] of directions) {
        let nr = row + dr, nc = col + dc;
        while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
          const target = board[nr][nc];
          if (!target) {
            moves.push([nr, nc]);
          } else if (isWhite ? isBlackPiece(target) : isWhitePiece(target)) {
            moves.push([nr, nc]);
            break;
          } else {
            break;
          }
          nr += dr;
          nc += dc;
        }
      }
    }

    function findKing(isWhite) {
      const king = isWhite ? '‚ôî' : '‚ôö';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (board[r][c] === king) return [r, c];
        }
      }
      return null;
    }

    function isInCheck(isWhite) {
      const kingPos = findKing(isWhite);
      if (!kingPos) return true;
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && (isWhite ? isBlackPiece(piece) : isWhitePiece(piece))) {
            const moves = getValidMoves(r, c);
            if (moves.some(m => m[0] === kingPos[0] && m[1] === kingPos[1])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function isCheckmate(isWhite) {
      if (!isInCheck(isWhite)) return false;
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && (isWhite ? isWhitePiece(piece) : isBlackPiece(piece))) {
            const moves = getValidMoves(r, c);
            for (const [nr, nc] of moves) {
              const captured = board[nr][nc];
              board[nr][nc] = piece;
              board[r][c] = '';
              const stillInCheck = isInCheck(isWhite);
              board[r][c] = piece;
              board[nr][nc] = captured;
              if (!stillInCheck) return false;
            }
          }
        }
      }
      return true;
    }

    function movePiece(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const captured = board[toRow][toCol];
      
      if (captured) {
        if (isWhitePiece(captured)) {
          blackCaptured.push(captured);
        } else {
          whiteCaptured.push(captured);
        }
      }

      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = '';

      if (piece === '‚ôô' && toRow === 0) {
        board[toRow][toCol] = '‚ôï';
      }
      if (piece === '‚ôü' && toRow === 7) {
        board[toRow][toCol] = '‚ôõ';
      }

      isWhiteTurn = !isWhiteTurn;
      selectedSquare = null;
      validMoves = [];
      
      renderBoard();
      updateTurnIndicator();
      renderCapturedPieces();

      if (isCheckmate(!isWhiteTurn)) {
        gameOver = true;
        setTimeout(() => {
          if (isWhiteTurn) {
            showGameOver();
          } else {
            showVictory();
          }
        }, 500);
        return;
      }

      if (!isWhiteTurn && !gameOver) {
        setTimeout(cpuMove, 600);
      }
    }

    function cpuMove() {
      if (gameOver) return;

      let bestMove = null;
      let bestScore = -Infinity;

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && isBlackPiece(piece)) {
            const moves = getValidMoves(r, c);
            for (const [nr, nc] of moves) {
              const captured = board[nr][nc];
              board[nr][nc] = piece;
              board[r][c] = '';
              
              if (!isInCheck(false)) {
                let score = 0;
                if (captured) score += PIECE_VALUES[captured] || 0;
                if (isInCheck(true)) score += 50;
                score += Math.random() * 10;
                
                if (score > bestScore) {
                  bestScore = score;
                  bestMove = { from: [r, c], to: [nr, nc] };
                }
              }
              
              board[r][c] = piece;
              board[nr][nc] = captured;
            }
          }
        }
      }

      if (bestMove) {
        movePiece(bestMove.from[0], bestMove.from[1], bestMove.to[0], bestMove.to[1]);
      }
    }

    function handleSquareClick(row, col) {
      if (gameOver || !isWhiteTurn) return;

      const piece = board[row][col];

      if (selectedSquare) {
        const isValidMove = validMoves.some(m => m[0] === row && m[1] === col);
        if (isValidMove) {
          const captured = board[row][col];
          board[row][col] = board[selectedSquare[0]][selectedSquare[1]];
          board[selectedSquare[0]][selectedSquare[1]] = '';
          
          if (isInCheck(true)) {
            board[selectedSquare[0]][selectedSquare[1]] = board[row][col];
            board[row][col] = captured;
            selectedSquare = null;
            validMoves = [];
            renderBoard();
            return;
          }
          
          board[selectedSquare[0]][selectedSquare[1]] = board[row][col];
          board[row][col] = captured;
          
          movePiece(selectedSquare[0], selectedSquare[1], row, col);
          return;
        }
      }

      if (piece && isWhitePiece(piece)) {
        selectedSquare = [row, col];
        validMoves = getValidMoves(row, col);
        renderBoard();
      } else {
        selectedSquare = null;
        validMoves = [];
        renderBoard();
      }
    }

    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          const isLight = (row + col) % 2 === 0;
          square.className = `square ${isLight ? 'bg-amber-100' : 'bg-amber-700'}`;
          
          if (selectedSquare && selectedSquare[0] === row && selectedSquare[1] === col) {
            square.classList.add('selected');
          }

          const isValidMove = validMoves.some(m => m[0] === row && m[1] === col);
          if (isValidMove) {
            if (board[row][col]) {
              square.classList.add('capture-move');
            } else {
              square.classList.add('valid-move');
            }
          }

          const piece = board[row][col];
          if (piece) {
            const pieceEl = document.createElement('span');
            pieceEl.className = 'chess-piece';
            pieceEl.textContent = piece;
            pieceEl.style.color = isWhitePiece(piece) ? '#ffffff' : '#1e293b';
            pieceEl.style.textShadow = isWhitePiece(piece) ? '0 2px 4px rgba(0,0,0,0.5)' : '0 2px 4px rgba(255,255,255,0.3)';
            square.appendChild(pieceEl);
          }

          square.addEventListener('click', () => handleSquareClick(row, col));
          boardEl.appendChild(square);
        }
      }
    }

    function updateTurnIndicator() {
      const indicator = document.getElementById('turn-indicator');
      if (gameOver) {
        indicator.textContent = 'Game Over';
        indicator.className = 'px-4 py-2 rounded-lg bg-red-600 text-white font-medium';
      } else if (isWhiteTurn) {
        indicator.textContent = 'Your Turn';
        indicator.className = 'px-4 py-2 rounded-lg bg-emerald-600 text-white font-medium';
      } else {
        indicator.textContent = 'CPU Thinking...';
        indicator.className = 'px-4 py-2 rounded-lg bg-slate-600 text-white font-medium';
      }
    }

    function renderCapturedPieces() {
      document.getElementById('white-captured').innerHTML = whiteCaptured.map(p => 
        `<span class="text-2xl" style="filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));">${p}</span>`
      ).join('');
      document.getElementById('black-captured').innerHTML = blackCaptured.map(p => 
        `<span class="text-2xl">${p}</span>`
      ).join('');
    }

    function createConfetti() {
      const colors = ['#fbbf24', '#f59e0b', '#eab308', '#fef08a', '#fde047'];
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = '-20px';
        confetti.style.width = Math.random() * 10 + 5 + 'px';
        confetti.style.height = Math.random() * 10 + 5 + 'px';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 2 + 's';
        confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
      }
    }

    function showVictory() {
      createConfetti();
      document.getElementById('victory-modal').classList.remove('hidden');
    }

    function showGameOver() {
      document.getElementById('game-over-modal').classList.remove('hidden');
    }

    function hideModals() {
      document.getElementById('victory-modal').classList.add('hidden');
      document.getElementById('game-over-modal').classList.add('hidden');
    }

    document.getElementById('reset-btn').addEventListener('click', () => {
      hideModals();
      initBoard();
    });

    document.getElementById('play-again-btn').addEventListener('click', () => {
      hideModals();
      initBoard();
    });

    document.getElementById('retry-btn').addEventListener('click', () => {
      hideModals();
      initBoard();
    });

    async function onConfigChange(config) {
      const title = config.game_title || defaultConfig.game_title;
      document.getElementById('game-title').textContent = title;
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [],
        borderables: [],
        fontEditable: undefined,
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    initBoard();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c4becae814a3ee0',t:'MTc2OTU1NTQzNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
